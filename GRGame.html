<!DOCTYPE html>
<html>
<head>
    <title>The unofficial GR rebrand game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #F0EFEF;
        }
        #content {
            max-width: 800px;
            margin: auto;
        }
        #gameCanvas {
            border: 1px solid black;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    <div id="content">
        <h1>The unofficial GR rebrand game</h1>
        <p>This applet displays a variation on <a href="https://en.wikipedia.org/wiki/Brian%27s_Brain", target="_blank">Brian's Brain cellular automaton</a>,
            slightly modified to accomodate four colours. It evolves according to the following rules:
        <ul>
            <li>Unactivated cells are blue.</li>
            <li>If an unactivated cell has exactly two activated neighbours (light grey), it activates.</li>
            <li>If an unactivated cell has more than two activated neighbours, it gets superactivated (yellow).</li>
            <li>Activated and superactivated cells turns into dead cells (black), and dead cells turn into unactivated cells.</li>
        </ul>
        <p>You can interact with the automaton by moving the mouse over the canvas while holding the Shift key down. This will activate any cell you mouse over. 
            Try also clicking holding down various combinations of the Shift and Ctrl keys...</p>
        <p>To just sit back and keep the action entertaining, enable random seeding: <input type="checkbox" id="randomnessCheckbox"><br> 
            Randomness amount (log10 of event probability):
            <input type="range" id="randomnessAmount" min="-8.0" max="-2.0" value="-5.0" step="0.05" oninput="updateRandomnessValue(this.value)"> <span id="randomnessAmountValue"></span></p>
            <button id="fullscreenButton">Go Fullscreen</button>
    </div><br>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <script>
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        let gridHeight = 100;
        let gridWidth = 100;
        let timeout = 50;
        let grid = null;
        let cellSize = canvas.width / gridWidth;
        let addRandomness = false;
        let randomnessAmount = -4.7;
        let gridPeriodicityShiftX = 0;
        let gridPeriodicityShiftY = 50;
        let gridFlipX = false;
        let gridFlipY = false;

        // Random seeds
        let pop1_mask = [[1, 1, 1], [1, 0, 1], [1, 1, 1]];
        let pop2_mask = [[1, 0, 1], [0, 1, 0], [1, 0, 1]];
        let pop3_mask = pop2_mask.map(row => row.map(val => 1 - val));
        //let pop4_mask = [[1, 1, 0], [1, 1, 0], [0, 0, 0]];
        let pop5_mask = [[0, 0, 0], [1, 1, 0], [0, 0, 0]];
        let pop6_mask = [[0, 1, 0], [0, 1, 0], [0, 0, 0]];
        let pop7_mask = [[1, 0, 1], [0, 0, 0], [1, 0, 1]];
        let pop_masks = [pop1_mask, pop2_mask, pop3_mask, pop5_mask, pop6_mask, pop7_mask];
        let prob = [0.3, 0.6, 0.9, 0.925, 0.95, 1.0];

        document.getElementById('fullscreenButton').addEventListener('click', function() {
            if (canvas.requestFullscreen) {
                canvas.requestFullscreen();
            } else if (canvas.mozRequestFullScreen) { // Firefox
                canvas.mozRequestFullScreen();
            } else if (canvas.webkitRequestFullscreen) { // Chrome, Safari and Opera
                canvas.webkitRequestFullscreen();
            } else if (canvas.msRequestFullscreen) { // IE/Edge
                canvas.msRequestFullscreen();
            }
        });
        document.getElementById('randomnessCheckbox').addEventListener('change', function() {
            addRandomness = this.checked; // Set the variable to the checkbox's state
        });
        function updateRandomnessValue(value) {
            randomnessAmount = value;
            document.getElementById('randomnessAmountValue').textContent = value;
        }
        function submitValue() {
            var userGridHeight = document.getElementById('userGridSize').value;
            var userGridWidth = document.getElementById('userGridSize').value;
            var userTimeout = document.getElementById('userTimeout').value;
            var userXShift = document.getElementById('userXShift').value;
            var userYShift = document.getElementById('userYShift').value;
            var userFlipX = document.getElementById('userFlipX').checked;
            var userFlipY = document.getElementById('userFlipY').checked;


            // Store the value in localStorage so it can be retrieved after the page reloads
            localStorage.setItem('userGridSize', userGridHeight);
            localStorage.setItem('userGridHeight', userGridHeight);
            localStorage.setItem('userGridWidth', userGridWidth);
            localStorage.setItem('userTimeout', userTimeout);
            localStorage.setItem('userXShift', userXShift);
            localStorage.setItem('userYShift', userYShift);
            localStorage.setItem('userFlipX', userFlipX);
            localStorage.setItem('userFlipY', userFlipY);

            // Reload the page
            location.reload();
        }

        window.onload = function() {
            if (localStorage.getItem('userGridSize') !== null) {
                gridHeight = parseInt(localStorage.getItem('userGridSize'));
                gridWidth = parseInt(localStorage.getItem('userGridSize'));
                cellSize = canvas.width / gridWidth;
                timeout = parseInt(localStorage.getItem('userTimeout'));
                gridPeriodicityShiftX = parseInt(localStorage.getItem('userXShift'));
                if (isNaN(gridPeriodicityShiftX))  gridPeriodicityShiftX = 0;
                if (isNaN(gridPeriodicityShiftY))  gridPeriodicityShiftY = 0;
                gridPeriodicityShiftY = parseInt(localStorage.getItem('userYShift'));
                gridFlipX = localStorage.getItem('userFlipX') === 'true';
                gridFlipY = localStorage.getItem('userFlipY') === 'true';
                console.log('Retrieved value from previous session: ' + gridHeight + '...');
            } else {
                console.log('No value in localStorage');
            }
            // Set the default values of the form inputs
            document.getElementById('userGridSize').value = gridHeight;
            //document.getElementById('userGridHeight').value = gridHeight;
            //document.getElementById('userGridWidth').value = gridWidth;
            document.getElementById('userTimeout').value = timeout;
            document.getElementById('userXShift').value = gridPeriodicityShiftX;
            document.getElementById('userYShift').value = gridPeriodicityShiftY;
            document.getElementById('userFlipX').checked = gridFlipX;
            document.getElementById('userFlipY').checked = gridFlipY;

            // Adjust the canvas size
            canvas.width = gridWidth * cellSize;
            canvas.height = gridHeight * cellSize;

            initializeGrid();
            gameLoop();
        }

        canvas.addEventListener('mousemove', function(event) {
            if (event.shiftKey){
                var rect = canvas.getBoundingClientRect();
                var x = event.clientX - rect.left;
                var y = event.clientY - rect.top;

                var i = Math.floor(x / cellSize);
                var j = Math.floor(y / cellSize);

                grid[i][j] = 1;
            }
        });

        canvas.addEventListener('mousedown', function(event) {
            var rect = canvas.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var y = event.clientY - rect.top;

            var i = Math.floor(x / cellSize);
            var j = Math.floor(y / cellSize);
            if (!event.shiftKey && !event.ctrlKey) {
                grid[(i+1) % gridHeight][(j+1) % gridWidth] = 1
                grid[(i-1+gridHeight) % gridHeight][(j+1) % gridWidth] = 1;
                grid[(i-1+gridHeight) % gridHeight][(j-1+gridWidth) % gridWidth] = 1
                grid[(i+1) % gridHeight][(j-1+gridWidth) % gridWidth] = 1;
            } else if (event.shiftKey && !event.ctrlKey) {
                grid[i][(j+1) % gridWidth] = 1
                grid[i][j] = 1;
                grid[(i+1) % gridHeight][j] = 1
            } else if (!event.shiftKey && event.ctrlKey) {
                grid[i][j] = 1;
                grid[(i+1) % gridHeight][j] = 1;
            } else if (event.shiftKey && event.ctrlKey) {
                grid[i][j] = 1;
                grid[i][(j+1) % gridWidth] = 1;
            }
        });

        // Initialize the grid randomly
        function initializeGrid() {
            grid = new Array(gridHeight);
            for (var i = 0; i < gridHeight; i++) {
                grid[i] = new Array(gridWidth);
                for (var j = 0; j < gridWidth; j++) {
                    var rnd = Math.random();
                    grid[i][j] = 0
                    grid[i][j] = rnd < 0.75 ? 1 : grid[i][j];
                    grid[i][j] = rnd < 0.5 ? 2 : grid[i][j];
                    grid[i][j] = rnd < 0.25 ? 3 : grid[i][j];
                }
            }
        }

        function findNeighbour(i, j, di, dj) {
            let ni = (i + di + gridHeight) % gridHeight;
            let nj = (j + dj + gridWidth) % gridWidth;
            let nni = ni;
            let nnj = nj;
            if (ni - i - di > 0) {
                if (gridFlipX) {
                    nnj = (gridWidth-nj - gridPeriodicityShiftX + gridWidth) % gridWidth;
                } else {
                    nnj = (nj + gridPeriodicityShiftX + gridWidth) % gridWidth;
                }
            } else if (ni - i - di < 0) {
                if (gridFlipX) {
                    nnj = (gridWidth-nj - gridPeriodicityShiftX + gridWidth) % gridWidth;
                } else {
                    nnj = (nj - gridPeriodicityShiftX + gridWidth) % gridWidth;
                }
            } 
            if (nj - j - dj > 0) {
                if (gridFlipY) {
                    nni = (gridHeight-ni - gridPeriodicityShiftY + gridHeight) % gridHeight;
                } else {
                    nni = (ni + gridPeriodicityShiftY + gridHeight) % gridHeight;
                }
            } else if (nj - j - dj < 0) {
                if (gridFlipY) {
                    nni = (gridHeight-ni - gridPeriodicityShiftY + gridHeight) % gridHeight;
                } else {
                    nni = (ni - gridPeriodicityShiftY + gridHeight) % gridHeight;
                }
            }

            return [nni, nnj];
        }

        function applyMask(grid, mask, i, j) {
            let maskHeight = mask.length;
            let maskWidth = mask[0].length;

            for (let mi = 0; mi < maskHeight; mi++) {
                for (let mj = 0; mj < maskWidth; mj++) {
                    // Calculate the grid coordinates with periodic boundary conditions
                    let di = mi - Math.floor(maskHeight / 2)
                    let dj = mj - Math.floor(maskWidth / 2)
                    let neighbour = findNeighbour(i, j, di, dj);
                    // Apply the mask
                    grid[neighbour[0]][neighbour[1]] = mask[mi][mj];
                }
            }
        }

        function drawGrid() {
            for (var i = 0; i < gridHeight; i++) {
                for (var j = 0; j < gridWidth; j++) {
                    ctx.fillStyle = 'rgb(247, 255, 28)';
                    if (grid[i][j] == 0) {
                        ctx.fillStyle = 'rgb(13, 112, 255)';
                    } else if (grid[i][j] == 1) {
                        ctx.fillStyle = 'rgb(240, 239, 239)';
                    } else if (grid[i][j] == 2) {
                        ctx.fillStyle = 'rgb(0, 0, 0)';
                    } else if (grid[i][j] > 3) {
                        ctx.fillStyle = 'rgb(0, 0, 0)';
                    }
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }

        function updateGrid() {
            var newGrid = new Array(gridHeight);
            for (var i = 0; i < gridHeight; i++) {
                newGrid[i] = new Array(gridWidth);
                for (var j = 0; j < gridWidth; j++) {
                    var neighbors = 0;
                    var sneighbors = 0;  // not used
                    for (var di = -1; di <= 1; di++) {
                        for (var dj = -1; dj <= 1; dj++) {
                            if (di == 0 && dj == 0) continue;
                            let neighbourCoord = findNeighbour(i, j, di, dj);
                            let ni = neighbourCoord[0];
                            let nj = neighbourCoord[1];
                            if (grid[ni][nj] == 1) {
                                neighbors += 1;
                                sneighbors += 1;
                            } else if (grid[ni][nj] == 3) {
                                sneighbors += 1;
                            }
                        }
                    }
                    if (grid[i][j] == 1 || grid[i][j] == 3) {
                        newGrid[i][j] = 2;
                    } else if (grid[i][j] == 2) {
                        newGrid[i][j] = 0;
                    } else if (grid[i][j] == 0 && neighbors == 2) {
                        newGrid[i][j] = 1;
                    } else if (grid[i][j] == 0 && neighbors > 2) {
                        newGrid[i][j] = 3;
                    } else {
                        newGrid[i][j] = 0;
                    }
                }
            }
            if (addRandomness) {
                for (var i = 0; i < gridHeight; i++) {
                    for (var j = 0; j < gridWidth; j++) {
                        var rnd1 = Math.random();
                        if (rnd1 < 10 ** randomnessAmount) {
                            var rnd2 = Math.random();
                            for (let k = 0; k < pop_masks.length; k++) {
                                if (rnd2 < prob[k]) {
                                    console.log("Applying mask " + k);
                                    applyMask(newGrid, pop_masks[k], i, j);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            grid = newGrid;
        }

        function gameLoop() {
            drawGrid();
            updateGrid();
            setTimeout(function() {
                requestAnimationFrame(gameLoop);
            }, timeout);
        }
    </script>
    <br>
    <div id="content">
        <label for="userGridSize">Grid size:</label>
        <input type="int" id="userGridSize" value="100">
        <!-- <label for="userGridHeight">Grid height:</label>
        <input type="int" id="userGridHeight" value="100">
        <label for="userGridWidth">Grid width:</label>
        <input type="int" id="userGridWidth" value="100"><br> -->
        <label for="userTimeout">Timeout (smaller is faster):</label>
        <input type="int" id="userTimeout" value="50"><br>
        <label for="userXShift">X periodicity shift:</label>
        <input type="int" id="userXShift" value="0">
        <label for="userYShift">Y periodicity shift:</label>
        <input type="int" id="userYShift" value="0"><br>
        <label for="userFlipX">Twisted boundary across X:</label>
        <input type="checkbox" id="userFlipX">
        <label for="userFlipY">Twisted boundary across Y:</label>
        <input type="checkbox" id="userFlipY"><br>
        <button onclick="submitValue()">Submit</button>
    </div>
</body>
</html>
